"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.odataifyFields = void 0;
const Entity_1 = require("../../types/Entity");
const IEntityReference_1 = require("../../types/IEntityReference");
const odataify_1 = require("./odataify");
const MetadataCache_1 = require("../../metadata/MetadataCache");
function odataifyFields(action, output, value, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const field of Object.keys(output)) {
            const fieldType = Object.prototype.toString.call(output[field]);
            const fieldValue = output[field];
            const fieldAttributeType = metadata.attributeTypes[field];
            // Convert primitive types
            switch (fieldAttributeType) {
                case "Integer" /* Integer */:
                    output[field] = fieldValue && parseInt(fieldValue);
                    break;
            }
            switch (fieldType) {
                case "[object Undefined]":
                    // When setting a value to undefined it must be null when sent to the WebApi
                    output[field] = null;
                    break;
                case "[object Array]":
                    // Array of Activity Parties or enums
                    // TODO: Add unit test for empty arrays
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const itemArray = fieldValue;
                    if (itemArray.length > 0) {
                        // What is the type of the items
                        const arrayType = itemArray[0].constructor.name;
                        switch (arrayType) {
                            case "Number":
                                output[field] = itemArray.join(",");
                                break;
                            case "Object":
                                // Is this an array of activity parties?
                                const party = itemArray[0];
                                if (party.partyid != null) {
                                    const activityPartiesField = `${metadata.logicalName}_activity_parties`;
                                    let activityParties = [];
                                    // Does the activity parties array already exist?
                                    if (!output[activityPartiesField]) {
                                        output[activityPartiesField] = activityParties;
                                    }
                                    else {
                                        activityParties = output[activityPartiesField];
                                    }
                                    for (const item of itemArray) {
                                        const webapiParty = (yield odataify_1.odataify("Create", item));
                                        // Map to the participation type mask
                                        let participationTypeMask;
                                        switch (field) {
                                            case "bcc":
                                                participationTypeMask = 4 /* BCC_Recipient */;
                                                break;
                                            case "cc":
                                                participationTypeMask = 3 /* CC_Recipient */;
                                                break;
                                            case "optional":
                                                participationTypeMask = 6 /* Optional_attendee */;
                                                break;
                                            case "requiredattendees":
                                                participationTypeMask = 5 /* Required_attendee */;
                                                break;
                                            case "from":
                                                participationTypeMask = 1 /* Sender */;
                                                break;
                                            case "to":
                                                participationTypeMask = 2 /* To_Recipient */;
                                                break;
                                            default:
                                                throw new Error(`Cannot map participation type mask for field ${field}`);
                                        }
                                        webapiParty.participationtypemask = participationTypeMask;
                                        activityParties.push(webapiParty);
                                    }
                                    // Remove the to/from/bcc/regarding field etc.
                                    delete output[field];
                                }
                                break;
                        }
                    }
                    else
                        output[field] = null;
                    break;
                case "[object Object]":
                    // Check if it's an EntityCollection
                    if (Entity_1.Entity.containsFields(fieldValue, ["entities"])) {
                        output[field] = yield odataify_1.odataify(action, fieldValue.entities);
                    }
                    // Create navigation properties for each entity reference
                    // Check for entity reference
                    else if (Entity_1.Entity.containsFields(fieldValue, ["id", "entityType"])) {
                        const entityRef = fieldValue;
                        let targetField = field;
                        // If there are multiple navigation types, then convert to the correct field name by adding _<logicalname>
                        const navigation = MetadataCache_1.caseInsensitiveSearch(field, metadata.navigation);
                        if (navigation != null) {
                            targetField = navigation.key;
                            if (navigation.value.length > 1) {
                                // This is a customer style field that has more than one target type
                                targetField = targetField + "_" + entityRef.entityType;
                            }
                        }
                        // Convert into odata navigation properties
                        output[`${targetField}@odata.bind`] = yield IEntityReference_1.getNavigationPathForEntityReference(value, field);
                        delete output[field];
                    }
                    break;
                case "[object Date]":
                    // If the time element is set for Date Time fields - format accordingly
                    const dateValue = fieldValue;
                    let dateString = dateValue.toJSON();
                    // If the date field is DateOnly:DateOnly then trim the value to have no time
                    if (dateString && metadata.attributeTypes[field] === "DateOnly:DateOnly") {
                        dateString = dateString.substring(0, 10);
                    }
                    output[field] = dateString;
                    break;
            }
        }
        return true;
    });
}
exports.odataifyFields = odataifyFields;
//# sourceMappingURL=odataifyFields.js.map