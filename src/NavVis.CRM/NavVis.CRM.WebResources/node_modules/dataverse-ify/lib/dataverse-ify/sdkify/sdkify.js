"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sdkify = void 0;
/* eslint-disable camelcase */
/* eslint-disable @typescript-eslint/camelcase */
const EntityReference_1 = require("../../types/EntityReference");
const AttributeTypes_1 = require("../../types/AttributeTypes");
const EntityCollection_1 = require("../../types/EntityCollection");
const dateReviver_1 = require("./dateReviver");
const getEntityMetadataFromRecord_1 = require("../../metadata/getEntityMetadataFromRecord");
const NullOrUndefined_1 = require("../../webapi/utils/NullOrUndefined");
// Remove the fields not needed (@ and _ fields)
function removeNonSdkFields(entityRecord) {
    for (const field of Object.keys(entityRecord)) {
        if (field.startsWith("_") || field.indexOf("@") > -1) {
            delete entityRecord[field];
        }
    }
}
// Expand out the activity party relationship array into to,from,bcc etc
function expandActivityPartiesToFields(entityRecord, activityPartiesField) {
    // In the UCI the expand navigation property returns a promise!
    const parties = entityRecord[activityPartiesField];
    let entities = [];
    if (parties.entities) {
        entities = parties.entities;
    }
    else {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        entities = parties;
    }
    for (const a of entities) {
        let partyField = null;
        // Determine which field to add to
        switch (a.participationtypemask) {
            case 4 /* BCC_Recipient */:
                partyField = "bcc";
                break;
            case 3 /* CC_Recipient */:
                partyField = "cc";
                break;
            case 6 /* Optional_attendee */:
                partyField = "optional";
                break;
            case 5 /* Required_attendee */:
                partyField = "requiredattendees";
                break;
            case 1 /* Sender */:
                partyField = "from";
                break;
            case 2 /* To_Recipient */:
                partyField = "to";
                break;
        }
        if (partyField != null) {
            let partyList = entityRecord[partyField];
            if (NullOrUndefined_1.isNullOrUndefined(partyList)) {
                partyList = [];
                entityRecord[partyField] = partyList;
            }
            partyList.push(a);
        }
    }
}
function sdkifyArray(value, logicalName) {
    return __awaiter(this, void 0, void 0, function* () {
        const cdsRecords = [];
        for (const record of value) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            cdsRecords.push((yield sdkify(record, logicalName)));
        }
        return new EntityCollection_1.EntityCollection(cdsRecords);
    });
}
function sdkifyEntityCollection(value, logicalName) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = value;
        const records = (yield sdkifyArray(response.entities, logicalName));
        records.pagingCooking = response.nextLink;
        return records;
    });
}
function sdkifyEntity(entityRecord, logicalName) {
    return __awaiter(this, void 0, void 0, function* () {
        const entityMetadata = getEntityMetadataFromRecord_1.getEntityMetadataFromRecord(entityRecord, logicalName);
        if (entityMetadata != null) {
            // Formatted values hold the text labels
            entityRecord.formattedValues = entityRecord.formattedValues || {};
            let activityPartiesField;
            // Turn each complex type property into the sdk fields
            for (const field of Object.keys(entityRecord)) {
                const posAt = field.lastIndexOf("@");
                const containsAt = posAt > -1;
                const navigationProperty = field.endsWith("@Microsoft.Dynamics.CRM.lookuplogicalname");
                const underscore = field.startsWith("_");
                if ((!containsAt && !underscore) || navigationProperty) {
                    let attributeValue = null;
                    let attributeType = AttributeTypes_1.AttributeTypes.Unknown;
                    let attributeLogicalName = field;
                    const attributeNameWithoutAt = field.substr(0, posAt);
                    /*
                    We need to determine which type the field is here
                    ---Dates---
                    Dates we use the 'DateReviver' pattern
                    however this is very inefficient since it runs the regex on every field value
            
                    ---EntityReference---
                    Entity reference we can infer from the presence of the Microsoft.Dynamics.CRM.lookuplogicalname
                    and Microsoft.Dynamics.CRM.associatednavigationproperty
                    _parentcustomerid_value@Microsoft.Dynamics.CRM.associatednavigationproperty=parentcustomerid_account
                    _parentcustomerid_value@Microsoft.Dynamics.CRM.lookuplogicalname=account
                    _parentcustomerid_value@OData.Community.Display.V1.FormattedValue=xyz
                                        
                    _primarycontactid_value@Microsoft.Dynamics.CRM.associatednavigationproperty=primarycontactid
                    _primarycontactid_value@Microsoft.Dynamics.CRM.lookuplogicalname=contact
                    _primarycontactid_value@OData.Community.Display.V1.FormattedValue=xyz
                    */
                    if (navigationProperty) {
                        attributeLogicalName = attributeNameWithoutAt;
                    }
                    const navigationPropertyName = attributeNameWithoutAt + "@Microsoft.Dynamics.CRM.associatednavigationproperty";
                    const lookupLogicalName = attributeNameWithoutAt + "@Microsoft.Dynamics.CRM.lookuplogicalname";
                    const formattedValueName = attributeLogicalName + "@OData.Community.Display.V1.FormattedValue";
                    if (attributeLogicalName.endsWith("_activity_parties")) {
                        attributeType = AttributeTypes_1.AttributeTypes.EntityCollection;
                    }
                    else if (navigationProperty && entityRecord[lookupLogicalName] != null) {
                        attributeType = AttributeTypes_1.AttributeTypes.EntityReference;
                    }
                    else {
                        let metadataType = entityMetadata.attributeTypes[field];
                        // For DateTimes, trim off the second part
                        metadataType = metadataType != null ? metadataType.split(":")[0] : "";
                        // TODO: Match strings to the optionset names?
                        switch (metadataType) {
                            case "Optionset":
                                attributeType = AttributeTypes_1.AttributeTypes.OptionSetValue;
                                break;
                            case "MultiSelect":
                                attributeType = AttributeTypes_1.AttributeTypes.MultiSelectOptionSetValue;
                                break;
                            case "Money":
                                attributeType = AttributeTypes_1.AttributeTypes.Money;
                                break;
                            case "DateOnly":
                            case "DateAndTime":
                                attributeType = AttributeTypes_1.AttributeTypes.DateTime;
                                break;
                            /*---Aliased Value---
                            There doesn't seem to be any way of determining of a returned field value is an aliased value
                            This means that there is no way of determining the type from querying metadata.
                            */
                        }
                    }
                    // Add the formatted value if there is one
                    if (entityRecord[formattedValueName] != null)
                        entityRecord.formattedValues[attributeLogicalName] = entityRecord[formattedValueName];
                    switch (attributeType) {
                        case AttributeTypes_1.AttributeTypes.EntityReference:
                            const entityType = entityRecord[lookupLogicalName];
                            attributeValue = new EntityReference_1.EntityReference(entityType, entityRecord[attributeLogicalName], entityRecord[formattedValueName]);
                            // Get the attribute logical name
                            const lookupAttributeName = entityRecord[navigationPropertyName];
                            if (attributeLogicalName.endsWith("_value") && attributeLogicalName.startsWith("_")) {
                                attributeLogicalName = attributeLogicalName.substr(1, attributeLogicalName.length - "_value".length - 1);
                            }
                            else if (lookupAttributeName != null) {
                                // Get the actual logical name of the attribute
                                if (lookupAttributeName.endsWith("_" + entityType)) {
                                    const typePos = lookupAttributeName.lastIndexOf("_" + entityType);
                                    attributeLogicalName = lookupAttributeName.substr(0, typePos);
                                }
                                else {
                                    attributeLogicalName = lookupAttributeName;
                                }
                            }
                            break;
                        case AttributeTypes_1.AttributeTypes.Money:
                            attributeValue = entityRecord[attributeLogicalName];
                            break;
                        case AttributeTypes_1.AttributeTypes.MultiSelectOptionSetValue:
                            attributeValue = entityRecord[attributeLogicalName];
                            if (attributeValue != null) {
                                const valueStrings = attributeValue.split(",");
                                const valueInts = [];
                                for (const v of valueStrings.reverse()) {
                                    valueInts.push(Number.parseInt(v));
                                }
                                attributeValue = valueInts;
                            }
                            if (entityRecord[formattedValueName] != null) {
                                entityRecord.formattedValues[attributeLogicalName] = entityRecord[formattedValueName];
                            }
                            break;
                        case AttributeTypes_1.AttributeTypes.OptionSetValue:
                            attributeValue = entityRecord[attributeLogicalName];
                            break;
                        case AttributeTypes_1.AttributeTypes.EntityCollection:
                            // Do we have the logical name of the relationship?
                            let navigationLogicalName = "";
                            if (field.endsWith("_activity_parties")) {
                                navigationLogicalName = "activityparty";
                                activityPartiesField = field;
                            }
                            else if (entityMetadata.navigation[field] != null) {
                                navigationLogicalName = entityMetadata.navigation[field][0];
                            }
                            // eslint-disable-next-line @typescript-eslint/no-use-before-define
                            attributeValue = yield sdkify(entityRecord[attributeLogicalName], navigationLogicalName);
                            break;
                        case AttributeTypes_1.AttributeTypes.DateTime:
                            attributeValue = new Date(Date.parse(entityRecord[attributeLogicalName]));
                            break;
                        default:
                            // Default - set primitive type value
                            attributeValue = entityRecord[attributeLogicalName];
                            break;
                    }
                    entityRecord[attributeLogicalName] = attributeValue;
                }
            }
            removeNonSdkFields(entityRecord);
            // If this is an activity party then populate the correct 'virtual field'
            if (activityPartiesField) {
                expandActivityPartiesToFields(entityRecord, activityPartiesField);
            }
        }
        entityRecord.logicalName = logicalName;
        return entityRecord;
    });
}
function sdkify(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
value, logicalName) {
    return __awaiter(this, void 0, void 0, function* () {
        if (value.json) {
            // This is a UCI response object and we need to await the json converstion
            value = yield value.json();
        }
        if (value.responseText) {
            // This is a raw execute response
            value = JSON.parse(value.responseText, dateReviver_1.dateReviver);
        }
        if (value.entities !== undefined) {
            return sdkifyEntityCollection(value, logicalName);
        }
        else if (value.constructor.name === "Array") {
            return sdkifyArray(value, logicalName);
        }
        else {
            return sdkifyEntity(value, logicalName);
        }
    });
}
exports.sdkify = sdkify;
//# sourceMappingURL=sdkify.js.map