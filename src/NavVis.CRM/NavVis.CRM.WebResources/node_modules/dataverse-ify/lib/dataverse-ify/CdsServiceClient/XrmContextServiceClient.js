"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrmContextCdsServiceClient = void 0;
const EntityCollection_1 = require("../../types/EntityCollection");
const EntityReference_1 = require("../../types/EntityReference");
const odataify_1 = require("../odataify/odataify");
const __1 = require("..");
const MetadataCache_1 = require("../../metadata/MetadataCache");
class XrmContextCdsServiceClient {
    constructor(webApi) {
        this._webApi = webApi;
    }
    create(entity) {
        return __awaiter(this, void 0, void 0, function* () {
            const record = yield odataify_1.odataify("Create", entity);
            const response = yield this._webApi.createRecord(entity.logicalName, record);
            return response.id;
        });
    }
    update(entity) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get the primary key attribute
            const entityMetadata = MetadataCache_1.getMetadataByLogicalName(entity.logicalName);
            // Convert null lookups to EntityReferences with null guid so we can run a delete association
            for (const attribute in entity) {
                const navigation = entityMetadata.navigation && entityMetadata.navigation[attribute];
                if (navigation && entity[attribute] === null) {
                    // We don't support just nulling a pollymorphic lookup because we don't know which relationship
                    // to null.
                    entity[attribute] = new EntityReference_1.EntityReference(navigation[0].replace("mscrm.", ""), null);
                }
            }
            const record = yield odataify_1.odataify("Update", entity);
            let id = entity[entityMetadata.primaryIdAttribute];
            // If there is no primary id attribute set, but the id is set then use that
            if (!id && entity.id) {
                id = entity.id;
            }
            else if (!id) {
                throw new Error("Either id or the primary id attribute must be set to update the record");
            }
            // Delete the lookups with null
            // Support for updating related entities separately like we do in the node implementation
            // otherwise we get "CRM do not support direct update of Entity Reference properties, Use Navigation properties instead."
            for (const attribute in record) {
                if (attribute.endsWith("@odata.bind") && record[attribute] && record[attribute].endsWith("(null)")) {
                    const dissassociateRequest = new (class {
                        constructor() {
                            this.target = {
                                id: id,
                                entityType: entity.logicalName,
                            };
                            this.relationship = attribute.substr(0, attribute.length - "@odata.bind".length);
                        }
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        getMetadata() {
                            return {
                                parameterTypes: {},
                                operationType: 2,
                                operationName: "Disassociate",
                            };
                        }
                    })();
                    yield Xrm.WebApi.online.execute(dissassociateRequest);
                    delete record[attribute];
                }
            }
            try {
                yield this._webApi.updateRecord(entity.logicalName, id, record);
            }
            catch (ex) {
                throw new Error("Error during update:" + ex.message);
            }
        });
    }
    delete(entity, id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof entity === "string") {
                yield this._webApi.deleteRecord(entity, id);
            }
            else {
                const entityValue = entity;
                yield this._webApi.deleteRecord(entityValue.logicalName, entityValue.id);
            }
        });
    }
    retrieve(entityName, id, columnSet) {
        return __awaiter(this, void 0, void 0, function* () {
            let query = "";
            const entityMetadata = MetadataCache_1.getMetadataByLogicalName(entityName);
            const cols = [];
            // When retreiving the activity parties - we simulate the SDK by making virtual fields
            // for sender, to, cc, bcc, required, optional, organizer
            const activitypartyAttributes = ["to", "from", "cc", "bcc", "required", "optional", "organizer"];
            let hasActivityPartyExpand = false;
            // Construct the select based on the columns requested
            // true means we return all the attributes
            if (columnSet && columnSet !== true) {
                for (const attribute of columnSet) {
                    if (activitypartyAttributes.indexOf(attribute) > -1) {
                        hasActivityPartyExpand = true;
                    }
                    else {
                        let correctedAttribute = attribute;
                        // If the attribute is a navigation property then format it correctly
                        if (entityMetadata.navigation) {
                            const navigation = MetadataCache_1.caseInsensitiveSearch(attribute, entityMetadata.navigation);
                            if (navigation) {
                                correctedAttribute = "_" + attribute + "_value";
                            }
                        }
                        cols.push(correctedAttribute);
                    }
                }
                query = `?$select=${cols.join(",")}`;
                if (hasActivityPartyExpand) {
                    query += `&$expand=${entityName}_activity_parties($select=activitypartyid,_partyid_value,participationtypemask)`;
                }
            }
            const response = yield this._webApi.retrieveRecord(entityName, id, query);
            const sdkified = (yield __1.sdkify(response, entityName));
            return sdkified;
        });
    }
    getEntityLogicalNameFromFetch(fetch) {
        let entityLogicalName = undefined;
        if (typeof DOMParser != "undefined") {
            const domParser = new DOMParser();
            const parsedFetch = domParser.parseFromString(fetch, "text/html");
            const entityNameNode = parsedFetch
                .getElementsByTagName("fetch")[0]
                .getElementsByTagName("entity")[0]
                .getAttributeNode("name");
            entityLogicalName = entityNameNode ? entityNameNode.value : "";
        }
        else {
            // Fall back to regex for when we are running inside a pure node test environment
            const regex = /name=["']?([\w]+)["']?/gm;
            const match = regex.exec(fetch);
            entityLogicalName = match && match.length > 0 ? match[1] : "";
        }
        if (entityLogicalName)
            return entityLogicalName;
        else
            throw new Error(`Cannot find entityLogicalName from fetchxml ${fetch}`);
    }
    retrieveMultiple(fetchxml) {
        return __awaiter(this, void 0, void 0, function* () {
            const logicalName = this.getEntityLogicalNameFromFetch(fetchxml);
            const results = yield this._webApi.retrieveMultipleRecords(logicalName, "?fetchXml=" + encodeURIComponent(fetchxml));
            const output = [];
            for (const record of results.entities) {
                const sdkified = (yield __1.sdkify(record, logicalName));
                output.push(sdkified);
            }
            const entities = new EntityCollection_1.EntityCollection(output);
            return entities;
        });
    }
    associate(_entityName, _entityId, _relationship, _relatedEntities) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Method not implemented.");
        });
    }
    disassociate(_entityName, _entityId, _relationship, _relatedEntities) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Method not implemented.");
        });
    }
    execute(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestWebApi = yield odataify_1.odataify("Action", request);
            const response = yield this._webApi.online.execute(requestWebApi);
            const responseText = yield response.text();
            if (responseText && responseText.length > 0) {
                return JSON.parse(responseText);
            }
            return undefined;
        });
    }
}
exports.XrmContextCdsServiceClient = XrmContextCdsServiceClient;
//# sourceMappingURL=XrmContextServiceClient.js.map