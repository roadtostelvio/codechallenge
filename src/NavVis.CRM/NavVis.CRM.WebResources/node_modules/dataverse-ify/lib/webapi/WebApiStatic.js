"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebApiStatic = void 0;
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable @typescript-eslint/no-unused-vars */
const adal_node_1 = require("adal-node");
const request = require("request");
const IEntityReference_1 = require("../types/IEntityReference");
const OperationType_1 = require("../types/OperationType");
const StructuralProperty_1 = require("../types/StructuralProperty");
const Guid_1 = require("../types/Guid");
const MetadataCache_1 = require("../metadata/MetadataCache");
const TokenCache_1 = require("./TokenCache");
const NullOrUndefined_1 = require("./utils/NullOrUndefined");
// Implementation of Xrm.WebApi for where Xrm.WebApi is not available
// E.g. Node Utilities or integration tests
class WebApiStatic {
    constructor(accessToken) {
        this.entitySetNames = {};
        this.webApiUrl = "";
        this.online = this;
        if (accessToken) {
            this.accessToken = accessToken;
        }
    }
    isAvailableOffline(_entityLogicalName) {
        throw new Error("Not implemented");
    }
    getClientUrl() {
        return this.server;
    }
    getOdataContext() {
        return this.server + "/$metadata#$ref";
    }
    getEntitySetName(logicalName) {
        return __awaiter(this, void 0, void 0, function* () {
            let metadata = this.entitySetNames[logicalName];
            if (!metadata) {
                // request https://org.crm11.dynamics.com/api/data/v9.0/EntityDefinitions(LogicalName='account')?$select=DisplayName,IsKnowledgeManagementEnabled,EntitySetName
                const path = `EntityDefinitions(LogicalName='${logicalName}')`;
                const apiResponse = yield this.webApiRequest("GET", undefined, path, "?$select=EntitySetName");
                metadata = apiResponse.data["EntitySetName"];
                this.entitySetNames[logicalName] = metadata;
            }
            return metadata;
        });
    }
    authoriseWithCdsAuthToken(server, apiVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            // Pick up the cds auth token cache
            this.server = server;
            this.apiVersion = apiVersion;
            this.apiPath = `/api/data/v${apiVersion}/`;
            this.accessToken = yield TokenCache_1.getAccessToken(server.replace("https://", ""));
        });
    }
    authoriseUserNamePassword(server, apiVersion, username, password, clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            const authorityHostUrl = "https://login.windows.net/common";
            this.server = server;
            this.apiVersion = apiVersion;
            this.apiPath = `/api/data/v${apiVersion}/`;
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const self = this;
            return new Promise((resolve, reject) => {
                const context = new adal_node_1.AuthenticationContext(authorityHostUrl);
                context.acquireTokenWithUsernamePassword(this.server, username, password, clientId, (err, tokenResponse) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        self.accessToken = tokenResponse.accessToken;
                        resolve(self.accessToken);
                    }
                });
            });
        });
    }
    createException(message, ex) {
        const innerEx = ex;
        if (innerEx.message !== undefined) {
            innerEx.message = message + ":" + innerEx.message;
            return innerEx;
        }
        else {
            return new Error(message + ":" + JSON.stringify(ex));
        }
    }
    /**
     * Creates an entity record
     * @param entityLogicalName Logical name of the entity you want to create. For example: "account".
     * @param record A JSON object defining the attributes and values for the new entity record.
     * @returns On success, returns a promise object containing the attributes specified earlier in the description of the successCallback parameter.
     * @see {@link https://docs.microsoft.com/en-us/dynamics365/customer-engagement/developer/clientapi/reference/xrm-webapi/createrecord External Link: createRecord (Client API reference)}
     */
    createRecord(entityLogicalName, record) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const entitySetName = yield this.getEntitySetName(entityLogicalName);
                const apiResponse = yield this.webApiRequest("POST", undefined, entitySetName, undefined, JSON.stringify(record));
                // Get the GUID from the OData-EntityId header
                const guidMatch = /\(([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\)/g.exec(apiResponse.headers["odata-entityid"]);
                if (guidMatch === null || guidMatch.length === 0)
                    throw new Error("Could not find the guid in the createRecord response");
                const guid = guidMatch[1];
                const response = {
                    entityType: entityLogicalName,
                    id: guid,
                };
                //   CodeGenerator.generateCreate(entityLogicalName, record, response);
                return response;
            }
            catch (ex) {
                throw this.createException("Exception in createRecord", ex);
            }
        });
    }
    /**
     * Updates an entity record.
     * @param entityLogicalName The entity logical name of the record you want to update. For example: "account".
     * @param id GUID of the entity record you want to update.
     * @param Data A JSON object containing key: value pairs, where key is the property of the entity and value is the value of the property you want update.
     * @returns On success, returns a promise object containing the attributes specified earlier in the description of the successCallback parameter.
     * @see {@link https://docs.microsoft.com/en-us/dynamics365/customer-engagement/developer/clientapi/reference/xrm-webapi/updaterecord External Link: updateRecord (Client API reference)}
     */
    updateRecord(entityLogicalName, id, data) {
        return __awaiter(this, void 0, void 0, function* () {
            NullOrUndefined_1.requireValue("entityLogicalName is a required parameter", entityLogicalName);
            NullOrUndefined_1.requireValue("id is a required parameter", id);
            NullOrUndefined_1.requireValue("data is a required parameter", data);
            try {
                const entitySetName = yield this.getEntitySetName(entityLogicalName);
                const path = `${entitySetName}(${this.toPathGuid(id)})`;
                yield this.webApiRequest("PATCH", undefined, path, undefined, JSON.stringify(data));
                const response = {
                    entityType: entityLogicalName,
                    id: id,
                };
                return response;
            }
            catch (ex) {
                throw this.createException("Exception in updateRecord", ex);
            }
        });
    }
    /**
     * Retrieves an entity record.
     * @param entityLogicalName The entity logical name of the record you want to retrieve. For example: "account".
     * @param id GUID of the entity record you want to retrieve.
     * @param options (Optional) OData system query options, $select and $expand, to retrieve your data.
     * - Use the $select system query option to limit the properties returned by including a comma-separated
     *   list of property names. This is an important performance best practice. If properties aren’t
     *   specified using $select, all properties will be returned.
     * - Use the $expand system query option to control what data from related entities is returned. If you
     *   just include the name of the navigation property, you’ll receive all the properties for related
     *   records. You can limit the properties returned for related records using the $select system query
     *   option in parentheses after the navigation property name. Use this for both single-valued and
     *   collection-valued navigation properties.
     * - You can also specify multiple query options by using & to separate the query options.
     * @example <caption>options example:</caption>
     * options: $select=name&$expand=primarycontactid($select=contactid,fullname)
     * @returns On success, returns a promise containing a JSON object with the retrieved attributes and their values.
     * @see {@link https://docs.microsoft.com/en-us/dynamics365/customer-engagement/developer/clientapi/reference/xrm-webapi/retrieverecord External Link: retrieveRecord (Client API reference)}
     */
    retrieveRecord(entityLogicalName, id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const entitySetName = yield this.getEntitySetName(entityLogicalName);
                // eslint-disable-next-line quotes
                const preferHeader = ['odata.include-annotations="*"'];
                const headers = {
                    Prefer: preferHeader.join(","),
                };
                const path = `${entitySetName}(${id})`;
                const apiResponse = yield this.webApiRequest("GET", headers, path, options);
                const data = apiResponse["data"];
                return data;
            }
            catch (error) {
                throw error;
            }
        });
    }
    /**
     * Deletes an entity record.
     * @param entityLogicalName The entity logical name of the record you want to delete. For example: "account".
     * @param id GUID of the entity record you want to delete.
     * @returns On success, returns a promise object containing the attributes specified earlier in the description of the successCallback parameter.
     * @see {@link https://docs.microsoft.com/en-us/dynamics365/customer-engagement/developer/clientapi/reference/xrm-webapi/deleterecord External Link: deleteRecord (Client API reference)}
     */
    deleteRecord(entityLogicalName, id) {
        return __awaiter(this, void 0, void 0, function* () {
            NullOrUndefined_1.requireValue("entityLogicalName is a required parameter", entityLogicalName);
            NullOrUndefined_1.requireValue("id is a required parameter", id);
            try {
                const entitySetName = yield this.getEntitySetName(entityLogicalName);
                const path = `${entitySetName}(${this.toPathGuid(id)})`;
                yield this.webApiRequest("DELETE", undefined, path);
                const response = {
                    entityType: entityLogicalName,
                    id: id,
                };
                return response;
            }
            catch (ex) {
                throw this.createException("Exception in deleteRecord", ex);
            }
        });
    }
    retrieveMultipleRecords(entityType, options, maxPageSize) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const entitySetName = yield this.getEntitySetName(entityType);
                // eslint-disable-next-line quotes
                const preferHeader = ['odata.include-annotations="*"'];
                if (maxPageSize !== undefined) {
                    preferHeader.push(`odata.maxpagesize=${maxPageSize.toString()}`);
                }
                const headers = {
                    Prefer: preferHeader.join(","),
                };
                const apiResponse = yield this.webApiRequest("GET", headers, entitySetName, options);
                const data = apiResponse["data"];
                const response = {
                    entities: data["value"],
                    nextLink: data["@odata.nextLink"],
                };
                //CodeGenerator.generateRetrieveMultiple(response, entityType, options, maxPageSize);
                return response;
            }
            catch (ex) {
                throw this.createException("Exception in retrieveMultipleRecords", ex);
            }
        });
    }
    execute(request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                NullOrUndefined_1.requireValue("Request cannot be null", request);
                // Currently the UCI requires us to have a class that defines the getMetadata rather than just a function
                // otherwise the getMetadata function is serialised into the request.
                const metadata = request.getMetadata();
                const verb = metadata.operationType === OperationType_1.OperationType.Action ? "POST" : "GET";
                let requestPayload = "";
                let queryString = "";
                let functionParametersString = "";
                let boundParameterValue;
                const functionParameters = [];
                const queryStringValues = [];
                let count = 0;
                const parameterObject = {};
                for (const key of Object.keys(request)) {
                    if (key === "getMetadata")
                        continue;
                    if (key === metadata.boundParameter) {
                        boundParameterValue = request[key];
                        continue;
                    }
                    const parameterName = `@p${count.toString()}`;
                    let parameterValue = request[key];
                    const parameterType = typeof parameterValue;
                    const parameterMetadata = metadata.parameterTypes[key];
                    if (parameterMetadata) {
                        const structuralType = parameterMetadata.structuralProperty;
                        const forUrl = verb === "GET";
                        parameterObject[key] = parameterValue;
                        switch (structuralType) {
                            case StructuralProperty_1.StructuralProperty.EntityType:
                                const valueEntityReference = parameterValue;
                                if (valueEntityReference.id && valueEntityReference.entityType) {
                                    if (forUrl) {
                                        // Url Entity reference
                                        const entitySetName = yield this.getEntitySetName(valueEntityReference.entityType);
                                        parameterValue = JSON.stringify({
                                            "@odata.id": IEntityReference_1.odatifyEntityReference(entitySetName, valueEntityReference.id),
                                        });
                                    }
                                    else {
                                        // POST entity reference
                                        const entityMetadata = MetadataCache_1.getMetadataByLogicalName(valueEntityReference.entityType);
                                        const entityReferenceParam = {};
                                        entityReferenceParam["@odata.type"] = "Microsoft.Dynamics.CRM." + valueEntityReference.entityType;
                                        entityReferenceParam[entityMetadata.primaryIdAttribute] = Guid_1.trimGuid(valueEntityReference.id);
                                        parameterObject[key] = entityReferenceParam;
                                    }
                                }
                                else {
                                    parameterValue = JSON.stringify(parameterValue);
                                }
                                break;
                            case StructuralProperty_1.StructuralProperty.PrimitiveType:
                                if (parameterType === "string") {
                                    // We need to wrap the string in single quotes
                                    parameterValue = `'${parameterValue.replace("'", "'")}'`;
                                }
                                else {
                                    parameterValue = JSON.stringify(parameterValue);
                                }
                                break;
                        }
                        functionParameters.push(`${key}=${parameterName}`);
                        queryStringValues.push(`${parameterName}=${parameterValue}`);
                        count++;
                    }
                }
                switch (metadata.operationType) {
                    case OperationType_1.OperationType.CRUD:
                        // Special Case for Associate/Dissasociate
                        yield this.executeCRUD(metadata, request);
                        return;
                        break;
                    case OperationType_1.OperationType.Action:
                        requestPayload = JSON.stringify(parameterObject);
                        break;
                    case OperationType_1.OperationType.Function:
                        functionParametersString = functionParameters.join(",");
                        queryString = queryStringValues.join("&");
                        break;
                }
                let path = functionParametersString !== ""
                    ? `${metadata.operationName}(${functionParametersString})`
                    : metadata.operationName;
                // If bound function/action then add the entity path
                if (boundParameterValue && metadata.boundParameter) {
                    const entityReference = boundParameterValue;
                    if (!entityReference.id)
                        throw new Error("No Id found on entity reference");
                    if (!entityReference.entityType)
                        throw new Error("No entityType found on entity reference");
                    const collectionName = yield this.getEntitySetName(entityReference.entityType);
                    const navigationPath = IEntityReference_1.odatifyEntityReference(collectionName, entityReference.id);
                    path = navigationPath + "/Microsoft.Dynamics.CRM." + path;
                }
                const apiResponse = yield this.webApiRequest(verb, undefined, path, queryString, requestPayload);
                const responseString = apiResponse["responseText"];
                const responseJson = responseString && responseString.length > 0 ? JSON.parse(apiResponse["responseText"]) : null;
                const jsonPromise = new Promise((resolve, _reject) => {
                    resolve(responseJson);
                });
                const responseTextPromise = new Promise((_resolve, _reject) => {
                    _resolve(responseString);
                });
                const executeResponse = {
                    ok: true,
                    json: () => {
                        return jsonPromise;
                    },
                    text: () => {
                        return responseTextPromise;
                    },
                    //type: "",
                    //headers: [],
                    status: 200,
                    //body: "",
                    statusText: "OK",
                    url: path,
                };
                //CodeGenerator.generateExcecute(request, executeResponse);
                return executeResponse;
            }
            catch (ex) {
                throw this.createException("Exception in execute", ex);
            }
            // ExecuteResponse
        });
    }
    executeMultiple(_request) {
        // ExecuteResponse[]
    }
    executeCRUD(metadata, request) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestWithTaret = request;
            const targetEntitySetName = yield this.getEntitySetName(requestWithTaret.target.entityType);
            //const relationship = request["relationship"] as string;
            // This is a special case for associate/disassociate
            switch (metadata.operationName) {
                case "Associate":
                    const associate = [];
                    const associateRequest = request;
                    for (const related of associateRequest.relatedEntities) {
                        const entitysetName = yield this.getEntitySetName(related.entityType);
                        associate.push({
                            "@odata.context": this.getOdataContext(),
                            "@odata.id": `${entitysetName}(${related.id})`,
                        });
                    }
                    if (associate.length > 1) {
                        const batch = [];
                        // We need to a batch request to associate multiple related entities
                        for (const record of associate) {
                            batch.push({
                                action: "POST",
                                path: `${targetEntitySetName}(${associateRequest.target.id})/${associateRequest.relationship}/$ref`,
                                data: JSON.stringify(record),
                            });
                        }
                        yield this.batchWebApiRequest(batch);
                    }
                    else {
                        // Get the target and related entities
                        const url = `${targetEntitySetName}(${associateRequest.target.id})/${associateRequest.relationship}/$ref`;
                        yield this.webApiRequest("POST", undefined, url, undefined, JSON.stringify(associate[0]));
                    }
                    break;
                case "Disassociate":
                    const disassociateRequest = request;
                    // Send a delete DELETE https://develop1v9demo.crm11.dynamics.com/api/data/v9.0/contacts(ca12bd9a-7b34-e911-a8b9-002248019477)/account_primary_contact(d012bd9a-7b34-e911-a8b9-002248019477)/$ref
                    let disassociateRequestRelatedEntityId = "";
                    if (disassociateRequest.relatedEntityId) {
                        // If clearing a lookup, then we don't supply disassociateRequest.relatedEntityId
                        disassociateRequestRelatedEntityId = `(${disassociateRequest.relatedEntityId})`;
                    }
                    const url = `${targetEntitySetName}(${disassociateRequest.target.id})/${disassociateRequest.relationship}${disassociateRequestRelatedEntityId}/$ref`;
                    yield this.webApiRequest("DELETE", undefined, url);
                    break;
            }
        });
    }
    getEntityMetadata(entityName, attributes) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const path = `EntityDefinitions(LogicalName='${entityName}')`;
                const options = attributes !== undefined ? `?$select=${attributes.join(",")}` : undefined;
                const apiResponse = yield this.webApiRequest("GET", undefined, path, options);
                return apiResponse["data"];
            }
            catch (ex) {
                throw this.createException("Exception in getEntityMetadata", ex);
            }
        });
    }
    dateReviver(_key, value) {
        if (typeof value === "string") {
            const a = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
            if (a) {
                return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6]));
            }
        }
        return value;
    }
    toPathGuid(id) {
        return id.replace(/[{}]/g, "");
    }
    batchWebApiRequest(requests) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = this.server + this.apiPath + "$batch";
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const self = this;
            const requestBody = [];
            const standardHeaders = this.getStandardHeaders();
            const batchId = "--batch_" + new Date().getTime();
            for (const request of requests) {
                requestBody.push(batchId);
                requestBody.push("Content-Type: application/http");
                requestBody.push("Content-Transfer-Encoding: binary");
                requestBody.push(`${request.action} ${request.path}`);
                requestBody.push("Accept: application/json");
                requestBody.push("Content-Type: application/json;type=entry");
                requestBody.push("");
                requestBody.push(JSON.stringify(request.data));
            }
            requestBody.push(batchId);
            const additionalHeaders = { "content-type": `multipart/mixed;boundary=${batchId}` };
            const requestOptions = {
                method: "POST",
                headers: Object.assign(Object.assign({}, standardHeaders), additionalHeaders),
            };
            return new Promise((resolve, reject) => {
                requestOptions.body = requestBody.join("\n");
                request(uri, requestOptions, (error, response) => {
                    if (error != null)
                        reject(error);
                    else {
                        const apiResponse = self.getResponse(response);
                        if (apiResponse.error != null) {
                            reject(apiResponse.error);
                        }
                        else {
                            resolve(apiResponse);
                        }
                    }
                });
            });
        });
    }
    trimOptions(options) {
        if (options !== undefined && options !== null) {
            if (!options.startsWith("?"))
                options = `?${options}`;
        }
        else {
            options = "";
        }
        return options;
    }
    getStandardHeaders() {
        const standardHeaders = {
            "OData-MaxVersion": "4.0",
            "OData-Version": "4.0",
            Accept: "application/json",
            "Content-Type": "application/json; charset=UTF-8",
            Authorization: `Bearer ${this.accessToken}`,
        };
        return standardHeaders;
    }
    webApiRequest(action, additionalHeaders, path, options, data) {
        return __awaiter(this, void 0, void 0, function* () {
            // Strip leading ? from query
            options = this.trimOptions(options);
            const uri = this.server + this.apiPath + path + options;
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const self = this;
            const hasData = data !== undefined && data !== null;
            const standardHeaders = this.getStandardHeaders();
            const headers = Object.assign(Object.assign({}, standardHeaders), additionalHeaders);
            const requestOptions = {
                method: action,
                headers: headers,
            };
            return new Promise((resolve, reject) => {
                if (hasData)
                    requestOptions.body = data;
                request(uri, requestOptions, (error, response) => {
                    if (error != null)
                        reject(error);
                    else {
                        const apiResponse = self.getResponse(response);
                        if (apiResponse.error != null) {
                            reject(apiResponse.error);
                        }
                        else {
                            resolve(apiResponse);
                        }
                    }
                });
            });
        });
    }
    getResponse(response) {
        let responseData = null;
        // Check if this is a batch response
        if (response.body.startsWith("--batchresponse_")) {
            // Batch - find the boundary
            const contentType = response.headers["content-type"].split(";");
            // Find the boundary
            for (const key of contentType) {
                if (key.trim().startsWith("boundary=")) {
                    // TODO: Get the batch responses
                }
            }
            responseData = null;
        }
        else {
            responseData =
                response.body != null && response.body.length > 0 ? JSON.parse(response.body, this.dateReviver) : null;
        }
        const apiResponse = {
            responseText: response.body,
            data: responseData,
            headers: response.headers,
            statusCode: response.statusCode,
            statusMessage: response.statusMessage,
            error: null,
        };
        if (response.statusCode < 200 || response.statusCode > 299) {
            // HTTP Error
            if (apiResponse.data !== undefined && apiResponse.data.error !== undefined) {
                apiResponse.error = apiResponse.data.error;
            }
            else {
                apiResponse.error = `HTTP Error ${response.statusMessage}`;
            }
        }
        return apiResponse;
    }
    request(action, path, payload, _includeFormattedValues, _maxPageSize) {
        debugger;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const hasData = payload !== undefined && payload !== null;
        const standardHeaders = this.getStandardHeaders();
        const headers = Object.assign({}, standardHeaders);
        const requestOptions = {
            method: action,
            headers: headers,
        };
        return new Promise((resolve, reject) => {
            if (hasData)
                requestOptions.body = JSON.stringify(payload);
            request(path, requestOptions, (error, response) => {
                if (error != null)
                    reject(error);
                else {
                    const apiResponse = self.getResponse(response);
                    if (apiResponse.error != null) {
                        reject(apiResponse.error);
                    }
                    else {
                        resolve(apiResponse);
                    }
                }
            });
        });
    }
}
exports.WebApiStatic = WebApiStatic;
//# sourceMappingURL=WebApiStatic.js.map