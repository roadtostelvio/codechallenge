"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccessToken = exports.getTokenFromCache = exports.addTokenToCache = exports.loadTokenCache = void 0;
const adal_node_1 = require("adal-node");
const os = require("os");
const path = require("path");
const fs = require("fs");
const Cryptr = require("cryptr");
let _inMemoryTokenCache;
function getAuthCachePath() {
    const homeDirPath = os.homedir();
    const authCachePath = path.join(homeDirPath, "cds-auth-cache");
    return authCachePath;
}
function getCrypto() {
    const cryptr = new Cryptr(os.userInfo.name);
    return cryptr;
}
function loadTokenCache() {
    if (!_inMemoryTokenCache) {
        const authCachePath = getAuthCachePath();
        let tokenCache = {};
        // Load existing file if there is one
        if (fs.existsSync(authCachePath)) {
            const tokenCacheJSON = fs.readFileSync(authCachePath);
            tokenCache = JSON.parse(tokenCacheJSON.toString());
        }
        _inMemoryTokenCache = tokenCache;
    }
    return _inMemoryTokenCache;
}
exports.loadTokenCache = loadTokenCache;
function addTokenToCache(envUrl, token) {
    const tokenCache = loadTokenCache();
    // Encrypt - not 100% secure, but just so we are not putting down plain text
    const jsonToken = JSON.stringify(token);
    const jsonTokenEncrypyed = getCrypto().encrypt(jsonToken);
    // Add to the token cache
    tokenCache[envUrl] = jsonTokenEncrypyed;
    _inMemoryTokenCache = tokenCache;
    fs.writeFileSync(getAuthCachePath(), JSON.stringify(tokenCache));
}
exports.addTokenToCache = addTokenToCache;
function getTokenFromCache(envUrl) {
    const tokenCache = loadTokenCache();
    const tokenEncrypted = tokenCache[envUrl];
    if (!tokenEncrypted) {
        throw new Error(`No token found for environment ${envUrl}`);
    }
    const jsonToken = getCrypto().decrypt(tokenEncrypted);
    return JSON.parse(jsonToken);
}
exports.getTokenFromCache = getTokenFromCache;
function getAccessToken(envUrl) {
    return new Promise(function (resolve, reject) {
        let accessToken = "";
        const token = getTokenFromCache(envUrl);
        const context = new adal_node_1.AuthenticationContext("https://login.windows.net/common");
        const server = "https://" + envUrl;
        const clientId = "51f81489-12ee-4a9e-aaae-a2591f45987d"; // Client ID used by Microsoft samples
        // Check if the token has expired
        const expiryDate = new Date(Date.parse(token.expiresOn.toString()));
        const nowDate = new Date();
        const expiresInMinutes = (expiryDate - nowDate) / 1000 / 60;
        const hasTokenExpired = expiresInMinutes < 5;
        if (hasTokenExpired) {
            // Get new token using refresh token
            context.acquireTokenWithRefreshToken(token.refreshToken, clientId, server, (err, tokenResponse) => {
                if (err) {
                    console.debug("Error:" + err);
                    reject(err);
                }
                else {
                    const newToken = tokenResponse;
                    console.debug(`Token refreshed until: ${tokenResponse.expiresOn}`);
                    addTokenToCache(envUrl, newToken);
                    accessToken = newToken.accessToken;
                    resolve(accessToken);
                }
            });
        }
        else {
            // Use current token
            accessToken = token.accessToken;
            resolve(accessToken);
        }
    });
}
exports.getAccessToken = getAccessToken;
//# sourceMappingURL=TokenCache.js.map