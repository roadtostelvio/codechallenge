"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeWebApiRequest = void 0;
const node_fetch_1 = require("node-fetch");
class NodeWebApiRequest {
    constructor(accessToken) {
        this.accessToken = accessToken;
    }
    send(action, uri, payload, includeFormattedValues, maxPageSize) {
        return __awaiter(this, void 0, void 0, function* () {
            // Construct a fully qualified URI if a relative URI is passed in.
            // This uses the static implementation of Xrm.Utility that should already be setup
            if (uri.charAt(0) === "/") {
                uri = Xrm.Utility.getGlobalContext().getClientUrl() + uri;
            }
            const accessToken = this.accessToken;
            const headers = new node_fetch_1.Headers();
            if (accessToken) {
                headers.append("Authorization", "Bearer " + accessToken);
            }
            headers.append("OData-MaxVersion", "4.0");
            headers.append("OData-Version", "4.0");
            //headers.append("Accept", "application/json");
            //headers.append("Content-Type", "application/json");
            if (maxPageSize) {
                headers.append("Prefer", "odata.maxpagesize=" + maxPageSize);
            }
            if (includeFormattedValues) {
                headers.append("Prefer", "odata.include-annotations=OData.Community.Display.V1.FormattedValue");
            }
            const response = yield node_fetch_1.default(encodeURI(uri), {
                method: action,
                body: JSON.stringify(payload),
                headers: headers,
            });
            let responseBody;
            const contentType = response.headers.get("Content-Type");
            if (contentType && contentType.indexOf("application/json") > -1) {
                responseBody = yield response.json();
            }
            else {
                responseBody = yield response.text();
            }
            if (response.ok) {
                return responseBody;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            else if (responseBody.error) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                throw responseBody.error;
            }
            else {
                throw "Unexpected Error";
            }
        });
    }
}
exports.NodeWebApiRequest = NodeWebApiRequest;
//# sourceMappingURL=NodeWebApiRequest.js.map