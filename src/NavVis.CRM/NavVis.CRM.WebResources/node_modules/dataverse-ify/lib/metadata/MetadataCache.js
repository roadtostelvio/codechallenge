"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.caseInsensitiveSearch = exports.getMetadata = exports.getEntitySetName = exports.getMetadataFromEntitySet = exports.getMetadataByLogicalName = exports.getMetadataCache = exports.setMetadataCache = exports._metadataCache = void 0;
const NullOrUndefined_1 = require("../webapi/utils/NullOrUndefined");
exports._metadataCache = { entities: {}, entitySetNames: {}, actions: {} };
function setMetadataCache(metadataCache) {
    exports._metadataCache = Object.assign(Object.assign({}, exports._metadataCache), metadataCache);
    // Add any EntitySetNames
    exports._metadataCache.entitySetNames = exports._metadataCache.entitySetNames || {};
    for (const logicalName in metadataCache.entities) {
        exports._metadataCache.entitySetNames[logicalName] = metadataCache.entities[logicalName].collectionName;
    }
}
exports.setMetadataCache = setMetadataCache;
function getMetadataCache() {
    if (NullOrUndefined_1.isNullOrUndefined(exports._metadataCache)) {
        throw new Error("Metadata cache is not initialised. Ensure that setMetadata is called");
    }
    return exports._metadataCache;
}
exports.getMetadataCache = getMetadataCache;
function getMetadataByLogicalName(logicalName) {
    const metadataCache = getMetadataCache();
    const metadata = metadataCache.entities && metadataCache.entities[logicalName];
    if (!metadata)
        throw new Error(`Metadata not found for ${logicalName}. Please create the early bound types.`);
    return metadata;
}
exports.getMetadataByLogicalName = getMetadataByLogicalName;
const entitySetNames = {};
function getMetadataFromEntitySet(entitySetName) {
    const metadataCache = getMetadataCache();
    if (metadataCache.entities) {
        // Check the metadata
        for (const logicalName of Object.keys(metadataCache.entities)) {
            // Check logical name
            const metadata = metadataCache.entities[logicalName];
            if (metadata.collectionName === entitySetName)
                return metadata;
        }
    }
    throw new Error(`Cannot find entity metadata for ${entitySetName}. Please generate early bound types`);
}
exports.getMetadataFromEntitySet = getMetadataFromEntitySet;
function getEntitySetName(entityLogicalName) {
    return __awaiter(this, void 0, void 0, function* () {
        const metadataCache = getMetadataCache();
        if (metadataCache.entitySetNames) {
            // Check the generated metadata
            const metadata = metadataCache.entitySetNames[entityLogicalName];
            if (metadata !== undefined) {
                return metadata;
            }
        }
        // Check the cache
        if (entitySetNames[entityLogicalName] !== undefined) {
            return entitySetNames[entityLogicalName];
        }
        // Lookup the entity set name from the logical name
        // We only lookup the entityset names automatically at the moment
        try {
            const entityMetadata = yield Xrm.Utility.getEntityMetadata(entityLogicalName, ["EntitySetName"]);
            entitySetNames[entityLogicalName] = entityMetadata.EntitySetName;
            return entityMetadata.EntitySetName;
        }
        catch (ex) {
            throw new Error(`Just-In-Time retreival of EntitySetName for '${entityLogicalName}' failed: ${ex}\nIdeally you should use setMetadataCache`);
        }
        //throw new Error(`Cannot find entity metadata for ${entityLogicalName}. Please generate early bound types`);
    });
}
exports.getEntitySetName = getEntitySetName;
function getMetadata(entity) {
    const logicalName = entity.logicalName;
    return getMetadataByLogicalName(logicalName);
}
exports.getMetadata = getMetadata;
function caseInsensitiveSearch(key, values) {
    key = key.toLowerCase();
    for (const index in values) {
        if (index.toLowerCase() === key) {
            return {
                key: index,
                value: values[index],
            };
        }
    }
    return undefined;
}
exports.caseInsensitiveSearch = caseInsensitiveSearch;
//# sourceMappingURL=MetadataCache.js.map